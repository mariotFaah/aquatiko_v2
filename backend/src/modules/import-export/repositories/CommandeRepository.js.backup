import BaseRepository from '../../../core/database/BaseRepository.js';
import Commande from '../entities/Commande.js';
import LigneCommande from '../entities/LigneCommande.js';

class CommandeRepository extends BaseRepository {
  constructor() {
    super('commandes');
  }

  async findAllWithRelations(filters = {}) {
    const query = this.db
      .select(
        'c.*',
        'client.nom as client_nom',
        'client.email as client_email',
        'fournisseur.nom as fournisseur_nom',
        'fournisseur.email as fournisseur_email'
      )
      .from('commandes as c')
      .leftJoin('tiers as client', 'c.client_id', 'client.id_tiers')
      .leftJoin('tiers as fournisseur', 'c.fournisseur_id', 'fournisseur.id_tiers');

    if (filters.type) query.where('c.type', filters.type);
    if (filters.statut) query.where('c.statut', filters.statut);
    if (filters.client_id) query.where('c.client_id', filters.client_id);

    const commandes = await query.orderBy('c.created_at', 'desc');

    return commandes.map(cmd => new Commande({
      ...cmd,
      client: { id: cmd.client_id, nom: cmd.client_nom, email: cmd.client_email },
      fournisseur: { id: cmd.fournisseur_id, nom: cmd.fournisseur_nom, email: cmd.fournisseur_email }
    }));
  }

  async findByIdWithRelations(id) {
    const commande = await this.db
      .select(
        'c.*',
        'client.nom as client_nom',
        'client.email as client_email',
        'client.telephone as client_telephone',
        'client.adresse as client_adresse',
        'fournisseur.nom as fournisseur_nom',
        'fournisseur.email as fournisseur_email',
        'fournisseur.telephone as fournisseur_telephone',
        'fournisseur.adresse as fournisseur_adresse'
      )
      .from('commandes as c')
      .leftJoin('tiers as client', 'c.client_id', 'client.id_tiers')
      .leftJoin('tiers as fournisseur', 'c.fournisseur_id', 'fournisseur.id_tiers')
      .where('c.id', id)
      .first();

    if (!commande) return null;

    // Récupérer les lignes de commande avec jointure articles corrigée
    const lignes = await this.db
      .select('lc.*', 'a.code_article as article_code', 'a.description as article_description')  // CORRECTION
      .from('lignes_commande as lc')
      .leftJoin('articles as a', 'lc.article_id', 'a.code_article')  // CORRECTION: code_article
      .where('lc.commande_id', id);

    // Récupérer l'expédition
    const expedition = await this.db
      .select('*')
      .from('expeditions')
      .where('commande_id', id)
      .first();

    // Récupérer les coûts logistiques
    const couts = await this.db
      .select('*')
      .from('couts_logistiques')
      .where('commande_id', id)
      .first();

    return new Commande({
      ...commande,
      client: {
        id: commande.client_id,
        nom: commande.client_nom,
        email: commande.client_email,
        telephone: commande.client_telephone,
        adresse: commande.client_adresse
      },
      fournisseur: {
        id: commande.fournisseur_id,
        nom: commande.fournisseur_nom,
        email: commande.fournisseur_email,
        telephone: commande.fournisseur_telephone,
        adresse: commande.fournisseur_adresse
      },
      lignes: lignes.map(l => new LigneCommande({
        ...l,
        article: l.article_id ? { 
          code_article: l.article_id,  // CORRECTION
          code: l.article_code,        // CORRECTION
          description: l.article_description  // CORRECTION
        } : null
      })),
      expedition: expedition,
      couts_logistiques: couts
    });
  }

  async createWithLignes(commandeData, lignesData = []) {
    return await this.db.transaction(async (trx) => {
      // Générer le numéro de commande
      const count = await trx('commandes').count('id as count').first();
      const numeroCommande = `CMD-${String(parseInt(count.count) + 1).padStart(6, '0')}`;

      // Créer la commande
      const [commandeId] = await trx('commandes').insert({
        ...commandeData,
        numero_commande: numeroCommande
      });

      // Créer les lignes de commande
      if (lignesData.length > 0) {
        const lignes = lignesData.map(ligne => ({
          ...ligne,
          commande_id: commandeId
        }));
        await trx('lignes_commande').insert(lignes);

        // Calculer le montant total
        const total = lignes.reduce((sum, ligne) => {
          return sum + (ligne.quantite * ligne.prix_unitaire * (1 + ligne.taux_tva / 100));
        }, 0);

        await trx('commandes').where('id', commandeId).update({ montant_total: total });
      }

      return commandeId;
    });
  }

  async updateStatut(id, statut) {
    return await this.db('commandes')
      .where('id', id)
      .update({ 
        statut, 
        updated_at: this.db.fn.now() 
      });
  }
}

export default CommandeRepository;
